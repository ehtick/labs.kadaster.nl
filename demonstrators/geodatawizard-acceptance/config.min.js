/******/ var __webpack_modules__ = ({

/***/ 4523:
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  }

  if (!url) {
    return url;
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = String(url.__esModule ? url.default : url);

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  }

  if (options.maybeNeedQuotes && /[\t\n\f\r "'=<>`]/.test(url)) {
    return "\"".concat(url, "\"");
  }

  return url;
};

/***/ }),

/***/ 1656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "13a194ebead0c473b516.png";

/***/ }),

/***/ 2180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "94a1cfc90856879051d2.png";

/***/ }),

/***/ 2749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "3c3436b4c0dbe4b8ce30.png";

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 	var document = __webpack_require__.g.document;
/******/ 	if (!scriptUrl && document) {
/******/ 		if (document.currentScript)
/******/ 			scriptUrl = document.currentScript.src;
/******/ 		if (!scriptUrl) {
/******/ 			var scripts = document.getElementsByTagName("script");
/******/ 			if(scripts.length) {
/******/ 				var i = scripts.length - 1;
/******/ 				while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 			}
/******/ 		}
/******/ 	}
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/******/ /* webpack/runtime/jsonp chunk loading */
/******/ (() => {
/******/ 	__webpack_require__.b = document.baseURI || self.location.href;
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		497: 0
/******/ 	};
/******/ 	
/******/ 	// no chunk on demand loading
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no HMR
/******/ 	
/******/ 	// no HMR manifest
/******/ 	
/******/ 	// no on chunks loaded
/******/ 	
/******/ 	// no jsonp function
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./src/assets/logo.png
const logo_namespaceObject = __webpack_require__.p + "d3bca066aeb4d1456c58.png";
// EXTERNAL MODULE: ./node_modules/html-loader/dist/runtime/getUrl.js
var getUrl = __webpack_require__(4523);
var getUrl_default = /*#__PURE__*/__webpack_require__.n(getUrl);
;// CONCATENATED MODULE: ./src/assets/landing.md
// Imports

var ___HTML_LOADER_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(1656), __webpack_require__.b);
var ___HTML_LOADER_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(2180), __webpack_require__.b);
var ___HTML_LOADER_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(2749), __webpack_require__.b);
// Module
var ___HTML_LOADER_REPLACEMENT_0___ = getUrl_default()(___HTML_LOADER_IMPORT_0___);
var ___HTML_LOADER_REPLACEMENT_1___ = getUrl_default()(___HTML_LOADER_IMPORT_1___);
var ___HTML_LOADER_REPLACEMENT_2___ = getUrl_default()(___HTML_LOADER_IMPORT_2___);
var code = "<h1 id=\"geodata-wizard\">GeoData Wizard</h1> <p>GeoData Wizard is een programma waarmee tabellen omgezet kunnen worden naar linked data.</p> <p><a href=\"./#1\" style=\"font-size:200%;font-weight:700\">Klik hier</a> om direct met de GeoData Wizard aan de slag te gaan.</p> <h2 id=\"hoe-werkt-de-geodata-wizard\">Hoe werkt de GeoData Wizard?</h2> <p>De GeoData Wizard stelt de gebruiker in staat om tabellen om te zetten naar linked data. Dit gebeurt aan de hand van de volgende 3 stappen:</p> <ul> <li>Stap 1: Upload</li> <li>Stap 2: Configure</li> <li>Stap 3: Publish</li> </ul> <h3 id=\"stap-1-upload\">Stap 1: Upload</h3> <p>GeoData Wizard kan bestanden in het CSV formaat inlezen. CSV staat voor &quot;Comma Separated Values&quot;. De meeste spreadsheet programma&#39;s (zoals MS Excel) en database programma&#39;s (zoals MS Access) hebben een standaard optie om data in dit formaat te exporteren.</p> <p>Wanneer het CSV bestand vanaf de harde schijf beschikbaar is kan het tijdens de &quot;Upload&quot; stap worden geselecteerd (Figuur 1).</p> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_0___ + "\"> <figcaption> Figuur 1 - De upload stap in de GeoData Wizard. </figcaption> </figure> <p>Wanneer geen eigen tabel voorhanden is kan ook gebruik worden gemaakt van een voorbeeld tabel door op &quot;example CSV file&quot; te klikken.</p> <h2 id=\"stap-2-configure\">Stap 2: Configure</h2> <p>Wanneer de data geüpload is in de GeoData Wizard kunnen we de transformatie gaan configureren. Deze configuratie bestaat uit de volgende stappen (Figuur 2):</p> <ol> <li>Stel in welke kolom wordt gebruikt voor identificatie.</li> <li>Stel in wat het type is van de objecten die in de rijen worden beschreven.</li> <li>Stel in welke eigenschap bij welke kolom hoort.</li> <li>Stel in welke verrijking moet worden toegepast op de cellen.</li> </ol> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_1___ + "\"> <figcaption> Figuur 2 - De configuratie stap in de GeoData Wizard. Dit is waar de transformatie wordt ingesteld. </figcaption> </figure> <h2 id=\"stap-3-publish\">Stap 3: Publish</h2> <p>Wanneer de GeoData Wizard de transformatie heeft uitgevoerd wordt deze in de volgende formaten aangeboden:</p> <ul> <li>Download het verrijkte CSV bestand</li> <li>Download de gegenereerde linked data</li> <li>Download het RML script dat kan worden doorontwikkeld</li> </ul> <p>Daarnaast kan de data direct worden geüpload naar de triple store van het Platform Linked Data Nederland (PLDN) of naar het Kadaster (Figuur 3).</p> <figure> <img src=\"" + ___HTML_LOADER_REPLACEMENT_2___ + "\"> <figcaption> Figuur 3 - De publicatie stap in de GeoData Wizard. </figcaption> </figure> <h2 id=\"waarom-linked-data\">Waarom linked data?</h2> <p>De kracht van linked data is dat datasets via het web aan elkaar kunnen worden gekoppeld. Bovendien worden in linked data standaarden toegepast waardoor de gegevens beter uitwisselbaar zijn. Neem een kijkje op <a href=\"https://www.pldn.nl/wiki/Wat_is_het\">de website van het Platform Linked Data Nederland</a> voor meer informatie over linked data.</p> ";
// Exports
/* harmony default export */ const landing = (code);
;// CONCATENATED MODULE: ./src/assets/kerken-nederland-geodatawizard.csv
const kerken_nederland_geodatawizard_namespaceObject = "﻿Kerk,Straat,Huisnummer,Postcode,Woonplaats,Denominatie,BAG ID,Punt coördinaat\r\nMunsterkerk,Munsterplein,12,6041HD,Roermond,Rooms-Katholiek Kerkgenootschap in Nederland,0957100000260969,Point(5.9885077122575 51.19355309031)\r\nDe Grote of St. Bavokerk te Haarlem,Oude Groenmarkt,3,2011HL,Haarlem,Protestantse Kerk in Nederland: Protestantse Gemeente,0392100000037432,Point(4.6367852414904 52.380867128717)\r\nPlein Kerk,Plein,27,3991DL,Houten,Hersteld Hervormde Kerk,0321100000006718,Point(5.1617524367345 52.027577800006)\r\nLutherse Kerk,Hondstraat,6,6211HX,Maastricht,Pinkstergemeente,0935100000019820,Point(5.6912975823322 50.847527370354)\r\nDoopsgezind Amsterdam,Singel,452,1017AW,Amsterdam,Algemene Doopsgezinde Sociëteit,0363100012177610,Point(4.888625965831 52.367707869405)\r\nOud-katholieke Parochie vd H.H Jacobus en Augustinus,Juffrouw Idastraat,7,2513BE,s-Gravenhage,Oud-Katholieke Kerk van Nederland,0518100000307537,Point(4.3061896277919 52.079387625716)\r\nPieterskerk,Pieterskerkhof,5,3512JR,Utrecht,Christian Science Nederland & School voor openbaar basisonderwijs,0344100000034484,Point(5.1245520254649 52.091139138425)\r\nOude Kerk Oosterbeek,Benedendorpseweg,134,6862WP,Oosterbeek,Protestantse Kerk in Nederland: Protestantse Gemeente,0274100000000610,Point(5.8377785440148 51.977972075089)\r\n";
;// CONCATENATED MODULE: ./src/transformations/index.ts
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function van_bag_id_naar_kkg_iri_f(_x) {
  return _van_bag_id_naar_kkg_iri_f.apply(this, arguments);
}
function _van_bag_id_naar_kkg_iri_f() {
  _van_bag_id_naar_kkg_iri_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
    var url, _results$, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-bag-id-naar-kkg-iri/run?id=".concat(id);
          _context.prev = 1;
          _context.next = 4;
          return fetchCall(url);
        case 4:
          results = _context.sent;
          if (!(results.length === 0)) {
            _context.next = 8;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context.abrupt("return", undefined);
        case 8:
          return _context.abrupt("return", results === null || results === void 0 || (_results$ = results[0]) === null || _results$ === void 0 ? void 0 : _results$.iri);
        case 11:
          _context.prev = 11;
          _context.t0 = _context["catch"](1);
          console.error(_context.t0);
          return _context.abrupt("return", undefined);
        case 15:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 11]]);
  }));
  return _van_bag_id_naar_kkg_iri_f.apply(this, arguments);
}
var van_bag_id_naar_kkg_iri = {
  type: 'single',
  label: 'Van BAG code naar Kadaster Knowledge Graph IRI',
  description: 'Gebruikt een kolom met codes die in de Basisregistratie Adressen en Gebouwen (BAG) voorkomen, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. De volgende BAG codes worden ondersteund: nummeraanduiding code, openbare ruimte code, pand code, verblijfsobject code, woonplaats code. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_bag_id_naar_kkg_iri_f
};
function van_wkt_punt_naar_kkg_gebouw_f(_x2) {
  return _van_wkt_punt_naar_kkg_gebouw_f.apply(this, arguments);
}
function _van_wkt_punt_naar_kkg_gebouw_f() {
  _van_wkt_punt_naar_kkg_gebouw_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(punt) {
    var url, _results$2, results;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-wkt-punt-naar-kkg-gebouw/run?punt=".concat(punt);
          _context2.prev = 1;
          _context2.next = 4;
          return fetchCall(url);
        case 4:
          results = _context2.sent;
          if (!(results.length === 0)) {
            _context2.next = 8;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context2.abrupt("return", undefined);
        case 8:
          return _context2.abrupt("return", results === null || results === void 0 || (_results$2 = results[0]) === null || _results$2 === void 0 ? void 0 : _results$2.iri);
        case 11:
          _context2.prev = 11;
          _context2.t0 = _context2["catch"](1);
          console.error(_context2.t0);
          return _context2.abrupt("return", undefined);
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[1, 11]]);
  }));
  return _van_wkt_punt_naar_kkg_gebouw_f.apply(this, arguments);
}
var van_wkt_punt_naar_kkg_gebouw = {
  type: 'single',
  label: 'Van punt coördinaat naar Kadaster Knowledge Graph gebouw IRI',
  description: 'Gebruikt een kolom met punt coördinaten in het Well-Known Text (WKT) formaat, en vindt de corresponderende gebouw IRI in de Kadaster Knowledge Graph. Een punt in het WKT formaat ziet er als volgt uit: "Point (5.95996114188 52.1796098569)" Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_wkt_punt_naar_kkg_gebouw_f
};
function van_wkt_punt_naar_kkg_perceel_f(_x3) {
  return _van_wkt_punt_naar_kkg_perceel_f.apply(this, arguments);
}
function _van_wkt_punt_naar_kkg_perceel_f() {
  _van_wkt_punt_naar_kkg_perceel_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(punt) {
    var url, _results$3, results;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          url = "https://api.labs.kadaster.nl/queries/GeoData-Wizard/van-wkt-punt-naar-kkg-perceel/run?punt=".concat(punt);
          _context3.prev = 1;
          _context3.next = 4;
          return fetchCall(url);
        case 4:
          results = _context3.sent;
          if (!(results.length === 0)) {
            _context3.next = 8;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context3.abrupt("return", undefined);
        case 8:
          return _context3.abrupt("return", results === null || results === void 0 || (_results$3 = results[0]) === null || _results$3 === void 0 ? void 0 : _results$3.iri);
        case 11:
          _context3.prev = 11;
          _context3.t0 = _context3["catch"](1);
          console.error(_context3.t0);
          return _context3.abrupt("return", undefined);
        case 15:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[1, 11]]);
  }));
  return _van_wkt_punt_naar_kkg_perceel_f.apply(this, arguments);
}
var van_wkt_punt_naar_kkg_perceel = {
  type: 'single',
  label: 'Van punt coördinaat naar Kadaster Knowledge Graph perceel IRI',
  description: 'Gebruikt een kolom met punt coördinaten in het Well-Known Text (WKT) formaat, en vindt de corresponderende perceel IRI in de Kadaster Knowledge Graph. Een punt in het WKT formaat ziet er als volgt uit: "Point (5.95996114188 52.1796098569)" Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_wkt_punt_naar_kkg_perceel_f
};
function van_bag_pand_id_naar_kkg_geometrie_f(_x4) {
  return _van_bag_pand_id_naar_kkg_geometrie_f.apply(this, arguments);
}
function _van_bag_pand_id_naar_kkg_geometrie_f() {
  _van_bag_pand_id_naar_kkg_geometrie_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {
    var url, _results$4, results;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          url = "https://data.pldn.nl/voor-bewoners/-/queries/van-bag-pand-id-naar-geometrie?id=".concat(id);
          _context4.prev = 1;
          _context4.next = 4;
          return fetchCall(url);
        case 4:
          results = _context4.sent;
          if (!(results.length === 0)) {
            _context4.next = 8;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context4.abrupt("return", undefined);
        case 8:
          return _context4.abrupt("return", results === null || results === void 0 || (_results$4 = results[0]) === null || _results$4 === void 0 ? void 0 : _results$4.wkt);
        case 11:
          _context4.prev = 11;
          _context4.t0 = _context4["catch"](1);
          console.error(_context4.t0);
          return _context4.abrupt("return", undefined);
        case 15:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[1, 11]]);
  }));
  return _van_bag_pand_id_naar_kkg_geometrie_f.apply(this, arguments);
}
var van_bag_pand_id_naar_kkg_geometrie = {
  type: 'single',
  label: 'Van BAG pand code naar geometrie',
  description: 'Gebruikt een kolom met pand codes die in de Basisregistratie Adressen en Gebouwen (BAG) voorkomen, en vindt de corresponderende geometrie in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_bag_pand_id_naar_kkg_geometrie_f
};
var pdok_locatie_server = 'https://api.pdok.nl/bzk/locatieserver/search/v3_1/free?fq=bron:BAG&q=';
function van_adres_en_woonplaats_naar_kkg_openbareRuimte_f(_x5, _x6) {
  return _van_adres_en_woonplaats_naar_kkg_openbareRuimte_f.apply(this, arguments);
}
function _van_adres_en_woonplaats_naar_kkg_openbareRuimte_f() {
  _van_adres_en_woonplaats_naar_kkg_openbareRuimte_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(straat, woonplaats) {
    var _response$response$do;
    var response, id;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return fetchCall("".concat(pdok_locatie_server).concat(straat, " ").concat(woonplaats));
        case 2:
          response = _context5.sent;
          id = (_response$response$do = response.response.docs[0]) === null || _response$response$do === void 0 ? void 0 : _response$response$do.openbareruimte_id;
          if (!(id === undefined)) {
            _context5.next = 9;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context5.abrupt("return", undefined);
        case 9:
          return _context5.abrupt("return", "https://data.kkg.kadaster.nl/id/openbareRuimte/".concat(id));
        case 10:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _van_adres_en_woonplaats_naar_kkg_openbareRuimte_f.apply(this, arguments);
}
var van_adres_en_woonplaats_naar_kkg_openbareRuimte = {
  type: 'double-column',
  label: 'Van straatnaam + woonplaats naam naar Kadaster Knowledge Graph openbare ruimte IRI',
  description: 'Gebruikt deze kolom met straatnamen en een tweede kolom met woonplaats namen, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_adres_en_woonplaats_naar_kkg_openbareRuimte_f
};
function van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f(_x7, _x8) {
  return _van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f.apply(this, arguments);
}
function _van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f() {
  _van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(postcode, huisnummer) {
    var _response$response$do2;
    var response, id;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return fetchCall("".concat(pdok_locatie_server).concat(postcode, " ").concat(huisnummer));
        case 2:
          response = _context6.sent;
          id = (_response$response$do2 = response.response.docs[0]) === null || _response$response$do2 === void 0 ? void 0 : _response$response$do2.nummeraanduiding_id;
          if (!(id === undefined)) {
            _context6.next = 9;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context6.abrupt("return", undefined);
        case 9:
          return _context6.abrupt("return", "https://data.kkg.kadaster.nl/id/nummeraanduiding/".concat(id));
        case 10:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f.apply(this, arguments);
}
var van_postcode_en_huisnummer_naar_kkg_nummeraanduiding = {
  type: 'double-column',
  label: 'Van postcode + huisnummer naar Kadaster Knowledge Graph nummeraanduiding IRI',
  description: 'Gebruikt deze kolom met postcodes en een tweede kolom met huisnummers, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_postcode_en_huisnummer_naar_kkg_nummeraanduiding_f
};
function van_woonplaats_naar_kkg_woonplaats_f(_x9) {
  return _van_woonplaats_naar_kkg_woonplaats_f.apply(this, arguments);
}
function _van_woonplaats_naar_kkg_woonplaats_f() {
  _van_woonplaats_naar_kkg_woonplaats_f = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(woonplaats) {
    var _response$response$do3, response, id;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _context7.next = 3;
          return fetchCall("".concat(pdok_locatie_server).concat(woonplaats));
        case 3:
          response = _context7.sent;
          id = (_response$response$do3 = response.response.docs[0]) === null || _response$response$do3 === void 0 ? void 0 : _response$response$do3.woonplaatscode;
          if (!(id === undefined)) {
            _context7.next = 10;
            break;
          }
          console.warn('No results found for refinement query.');
          return _context7.abrupt("return", undefined);
        case 10:
          return _context7.abrupt("return", "https://data.kkg.kadaster.nl/id/woonplaats/".concat(id));
        case 11:
          _context7.next = 17;
          break;
        case 13:
          _context7.prev = 13;
          _context7.t0 = _context7["catch"](0);
          console.error(_context7.t0);
          return _context7.abrupt("return", undefined);
        case 17:
        case "end":
          return _context7.stop();
      }
    }, _callee7, null, [[0, 13]]);
  }));
  return _van_woonplaats_naar_kkg_woonplaats_f.apply(this, arguments);
}
var van_woonplaats_naar_kkg_woonplaats = {
  type: 'single',
  label: 'Van woonplaats naam naar Kadaster Knowledge Graph woonplaats IRI',
  description: 'Gebruikt de woonplaats namen in deze kolom, en vindt de corresponderende IRI in de Kadaster Knowledge Graph. Voor meer informatie over de Kadaster Knowledge Graph, zie https://data.kkg.kadaster.nl',
  transformation: van_woonplaats_naar_kkg_woonplaats_f
};
function fetchCall(_x10) {
  return _fetchCall.apply(this, arguments);
}
function _fetchCall() {
  _fetchCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
    var response;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return fetch(request, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
        case 2:
          response = _context8.sent;
          if (response.ok) {
            _context8.next = 7;
            break;
          }
          throw new Error("".concat(request, " returned ").concat(response.status));
        case 7:
          return _context8.abrupt("return", response.json());
        case 8:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _fetchCall.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/config.ts
function config_typeof(obj) { "@babel/helpers - typeof"; return config_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, config_typeof(obj); }
function config_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ config_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == config_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(config_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function config_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { config_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var wizardConfig = {
  appName: 'GeoData Wizard',
  classConfig: {
    method: 'elastic',
    endpoint: 'https://api.labs.kadaster.nl/datasets/GeoData-Wizard/vocabulaires/services/search/search/'
  },
  columnRefinements: [van_bag_id_naar_kkg_iri, van_wkt_punt_naar_kkg_gebouw, van_wkt_punt_naar_kkg_perceel, van_woonplaats_naar_kkg_woonplaats, van_postcode_en_huisnummer_naar_kkg_nummeraanduiding, van_adres_en_woonplaats_naar_kkg_openbareRuimte, van_bag_pand_id_naar_kkg_geometrie],
  dataplatformLink: 'https://data.pldn.nl',
  defaultBaseIri: 'https://data.pldn.nl/',
  exampleCSV: kerken_nederland_geodatawizard_namespaceObject,
  favIcon: logo_namespaceObject,
  getAllowedPrefixes: function () {
    var _getAllowedPrefixes = config_asyncToGenerator( /*#__PURE__*/config_regeneratorRuntime().mark(function _callee() {
      var response, prefixes;
      return config_regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch('https://api.labs.kadaster.nl/datasets/GeoData-Wizard/vocabulaires/prefixes');
          case 2:
            response = _context.sent;
            if (!response.ok) {
              _context.next = 10;
              break;
            }
            _context.next = 6;
            return response.json();
          case 6:
            prefixes = _context.sent;
            return _context.abrupt("return", prefixes);
          case 10:
            throw new Error("Failed to fetch prefixes, status code: ".concat(response.status));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getAllowedPrefixes() {
      return _getAllowedPrefixes.apply(this, arguments);
    }
    return getAllowedPrefixes;
  }(),
  homepageMarkdown: landing,
  icon: logo_namespaceObject,
  newDatasetAccessLevel: 'public',
  predicateConfig: {
    method: 'elastic',
    endpoint: 'https://api.labs.kadaster.nl/datasets/GeoData-Wizard/vocabulaires/services/search/search/'
  },
  primaryColor: '#00387d',
  publishOrder: ['download', 'triplyDB'],
  secondaryColor: '#008296',
  triplyDbInstances: [{
    label: 'PLDN',
    link: 'https://data.pldn.nl'
  }, {
    label: 'Kadaster',
    link: 'https://data.labs.kadaster.nl'
  }]
};
/* harmony default export */ const config = (globalThis.wizardConfig = wizardConfig);
})();

