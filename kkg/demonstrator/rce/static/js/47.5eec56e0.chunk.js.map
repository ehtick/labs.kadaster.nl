{"version":3,"sources":["components/widgets/bb/BBSVGEditor.js"],"names":["BBSVGEditor","getUrl","window","bbFolderName","convertToDxf","svgEl","blocks","svg","SVG","dxf","DxfWriter","addTextsToDXF","addCirclesToDXF","addPathToDXF","dxfString","stringify","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","click","revokeObjectURL","showToast","e","console","log","circles","find","me","forEach","circle","addCircleToDXF","addPolygonToDXF","texts","text","addTextToDXF","paths","path","addPath","parseTranslation","transformString","match","exec","split","map","Number","tx","ty","parseTransform","transform","x","y","includes","trans","this","rotateMatch","rotation","angle","parseFloat","cx","cy","matrixMatch","matrix","a","b","c","d","f","transformPoint","rad","Math","PI","rotatedX","cos","sin","rotatedY","textElement","block","getBlock","parent","attr","fontSize","addText","point3d","parentGroup","r","addCircle","pathElement","pathData","array","strokeWidth","coordinates","groeps","push","command","points","i","length","line","addLine","thickness","lineType","lineScale","colorNumber","Colors","Black","Grey","lineTypeScale","scrolling","noEvents","usesParameters","element","dblock","addBlock","addInsert","id","node","getAttribute","replace","BBIFrame"],"mappings":"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","file":"static/js/47.5eec56e0.chunk.js","sourcesContent":["import './bbutil'\n\n\nimport BBIFrame from './BBIFrame';\nimport { DxfWriter, point3d,Colors } from \"@tarikjabiri/dxf\";\nimport { SVG } from '@svgdotjs/svg.js'\n\n\n\n\n\nclass BBSVGEditor extends BBIFrame{\n  \n \n  getUrl = () => `/${window.bbFolderName}/static/iframes/svgeditor/index.html`\n\n\n  constructor() {\n    super()\n\n    this.scrolling = 'no';\n    this.noEvents = false;\n    this.usesParameters=false;\n  }\n  convertToDxf =  (svgEl) => \n    {\n      try\n      {\n        //console.log(\"convert to dxf\",svg)\n        this.blocks=null;\n    var svg=SVG(svgEl)\n    const dxf = new DxfWriter();\n    \n\n    this.addTextsToDXF(dxf,svg); //this one first or else it does not work...\n\n    this.addCirclesToDXF(dxf,svg);\n\n    //dxf.addText(point3d(10, 10),10,\"Hello, DXF!\")\n    this.addPathToDXF(dxf,svg);\n    // not implemented\n    //this.addPolygonToDXF(dxf,svg)\n    //this.addRectangeToDXF(dxf,svg)\n    \n\n\n\n     // To get the dxf string just call the stringify() method\n    const dxfString = dxf.stringify();\n   // console.log(\"writing dxf file,\",dxfString.length)\n    const blob = new Blob([dxfString], { type: \"application/dxf\" });\n     const url = URL.createObjectURL(blob);\n\n     const link = document.createElement(\"a\");\n     link.href = url;\n     link.download = \"BIM-LEGAL-Splitsingstekening.dxf\";\n     link.click();\n\n     URL.revokeObjectURL(url); // Clean up\n     this.showToast(\"Dxf file is available in the downloads\")\n   \n    //return dxfString\n      }\n      catch(e)\n      {\n        console.log(e)\n        this.showToast(\"ERROR: could not generate dxf\")\n        return;\n       //  this.showToast(\"could not generate dxf\")\n      }\n\n   return null\n  }\n  addCirclesToDXF = (dxf,svg) =>\n    {\n      const circles  = svg.find('circle');\n      var me=this;\n      circles.forEach(circle  => {me.addCircleToDXF(dxf,circle)})\n    }\n    addPolygonToDXF = (dxf,svg) =>\n    {\n      const polygons  = svg.find('polygon');\n      var me=this;\n\n     // dxf.addPolyline2D(vertices, { layer: 'PolygonLayer', closed: true });\n    }\n\n  addTextsToDXF = (dxf,svg) =>\n    {\n      const texts = svg.find('text');\n      var me=this;\n       texts.forEach(text => {me.addTextToDXF(dxf,text)})\n    }\n\n  addPathToDXF = (dxf,svg) =>\n  {\n    const paths = svg.find('path');\n    var me=this;\n     paths.forEach(path => {me.addPath(dxf,path)})\n  }\n\n  parseTranslation=function(transformString)\n   {\n    \n    const match = /translate\\(([^)]+)\\)/.exec(transformString);\n    if (match) {\n        const [tx, ty] = match[1].split(/[\\s,]+/).map(Number);\n        return { tx: tx || 0, ty: ty || 0 };\n    }\n    return { tx: 0, ty: 0 };\n  }\n\n  parseTransform=function(transform,x,y)\n  {\n    \n    if (transform.includes(\"translate\"))\n    {\n      var trans=this.parseTranslation(transform);\n      return ({x:x+trans.tx,y:-(y+trans.ty)})\n    }\n    if (transform.includes(\"matrix\"))\n    {\n      const rotateMatch = transform.match(/rotate\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/);\n      const rotation = {\n        angle: parseFloat(rotateMatch[1]),\n        cx: parseFloat(rotateMatch[2]),\n        cy: parseFloat(rotateMatch[3])\n          };\n\n          // Extract matrix using regex\n          const matrixMatch = transform.match(/matrix\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/);\n          const matrix = {\n            a: parseFloat(matrixMatch[1]),\n            b: parseFloat(matrixMatch[2]),\n            c: parseFloat(matrixMatch[3]),\n            d: parseFloat(matrixMatch[4]),\n            e: parseFloat(matrixMatch[5]),\n            f: parseFloat(matrixMatch[6])\n          };\n                return this.transformPoint(x,y,rotation.angle,rotation.cx,rotation.cy,matrix)\n      \n    }\n    if (transform==null)\n    {\n      return {x:x,y:-y}\n    }\n    //console.log(\"unsupported transform\")\n    return {x:x,y:-y}\n\n\n  }\n\n\n transformPoint=function(x, y, rotation, cx, cy, matrix) {\n \n  const rad = (Math.PI / 180) * rotation; // Convert degrees to radians\n\n  // Step 1: Rotate around (cx, cy)\n  const rotatedX =\n    cx + (x - cx) * Math.cos(rad) - (y - cy) * Math.sin(rad);\n  var rotatedY =\n    cy + (x - cx) * Math.sin(rad) + (y - cy) * Math.cos(rad);\n   rotatedY = -rotatedY\n  // Step 2: Apply matrix transformation\n  const transformedX = rotatedX * matrix.a + rotatedY * matrix.c + matrix.e;\n  const transformedY = rotatedX * matrix.b + rotatedY * matrix.d + matrix.f;\n\n  return { x: transformedX, y: transformedY };\n}\n\n\n\n\naddTextToDXF = function(dxf,textElement) {\n\n    var block =this.getBlock(dxf,textElement);\n    const parentGroup = textElement.parent();\n    const transform = parentGroup.attr('transform') || '';\n    const { x, y } = this.parseTransform(transform,textElement.attr('x'), textElement.attr('y'));\n    \n    const text = textElement.text();\n    const fontSize = textElement.attr('font-size')||7;\n    const fontFamily = textElement.attr('font-family')||'Arial';\n    //console.log(\"add text\",text,x,y,fontSize)\n    //10, 10),10,\"Hello, DXF!\")\n   // if (text===\"N\") return;\n    if (text===\"0m\") return;\n    if (text===\"20m\") return;\n    if (text===\"gemeenschappelijke ruimtes\") return;\n    block.addText(point3d(x, (y)), fontSize, \"\"+text);\n    \n}\n   insertBlocks(dxf)\n   {\n\n   }\n\n  getBlock(dxf,element)\n  {\n    if (this.blocks==null)\n      {\n         this.blocks={};\n         var dblock =dxf.addBlock(\"default\");\n         this.blocks.dblock=dblock;\n         dxf.addInsert(\"default\", point3d(0, 0, 0));\n\n      }\n      try\n      {\n        var parent= element.parent().parent();\n       \n        var id = parent.node.getAttribute(\"id\");\n        id=id.replace(\"_\",\"\");\n       // console.log(id, parent.node.getAttribute(\"transform\"))\n        if (id!=null)\n        {\n          var block=this.blocks[id];\n          if (block==null)\n          {\n           // console.log(\"CREATE BLOCK \",id)\n          \n            block =dxf.addBlock(id);\n            this.blocks[id]=block;\n            const transform = parent.node.getAttribute(\"transform\");\n           // console.log(\"transform\",transform)\n           var tx=0;\n           var ty=0;\n           try\n           {\n            const { x, y } = this.parseTransform(transform,0,0)\n             tx=x; ty=y;\n           }\n           catch(e){}\n\n           \n            // get translate from parent\n           \n            //dxf.addInsert(id+\"\", point3d(0, 0, 0));\n            if (tx<0)tx=0;\n            if (ty<0)ty=0;\n            dxf.addInsert(id, point3d(tx,ty ));\n            block.addText(point3d(0, 0), 1, '')\n         //   console.log(\"inserting block \",id,tx,ty)\n\n            return block;\n           \n          }\n        }\n       // console.log(parent.id);\n      }\n      catch(e)\n      {}\n      return this.blocks.dblock;\n\n\n    \n  }\n// getParentXY(element)\n// {\n//   var px=0;var py=0;\n//   var grandparent=element.parent();\n//   if (grandparent!=null)\n//   {\n//     const transform = grandparent.attr('transform') || '';\n//     console.log(\"tranformgroup parent\",transform);\n//     const { x, y } = this.parseTransform(transform,0,0);\n//     px=x;\n//     py=y;\n//   }\n//   return {px:px,py:-py}\n// }\naddCircleToDXF = function(dxf,textElement) {\n\n  const parentGroup = textElement.parent();\n  //const { px, py } =this.getParentXY(parentGroup);\n  var block =this.getBlock(dxf,textElement);\n\n \n  const transform = parentGroup.attr('transform') || '';\n  const { x, y } = this.parseTransform(transform,textElement.attr('cx'),textElement.attr('cy'));\n  const r= textElement.attr('r')\n // console.log(\"add circle\",x,y,r)\n // if (r>20)return;\n  if (r<5)return;\n  block.addCircle(point3d(x, (y)),r );\n \n  \n}\n    \n\n  \n   addPath = function(dxf,pathElement) {\n    const pathData = pathElement.array(); // Get path commands as an array\n    const parentGroup = pathElement.parent();\n\n    const transform = parentGroup.attr('transform') || '';\n  \n    //const { tx, ty } = this.parseTranslation(transform);\n    var strokeWidth=pathElement.attr('stroke-width')||0.5;\n    var block=this.getBlock(dxf,pathElement);\n\n    //const { px, py } =this.getParentXY(parentGroup)\n    //console.log(\"path \",px,py)\n    \n \n    \n    \n    var coordinates = [];\n    const groeps=[]\n    groeps.push(coordinates)\n\n    // Iterate over path commands\n    pathData.forEach(([command, ...points]) => {\n      if (command === 'M') \n        {\n         coordinates=[]\n         groeps.push(coordinates)\n        }\n        for (let i = 0; i < points.length; i += 2) {\n            const { x, y } =this.parseTransform(transform,points[i],points[i + 1])\n            // const x = points[i] + tx;\n            // const y = points[i + 1] + ty;\n            \n            // const tx=x;//+px;\n            // const ty=y;//+py;\n            coordinates.push({ x, y });\n        }\n    });\n\n    for (let i = 0; i < groeps.length; i++) {\n         coordinates=groeps[i]\n        if (coordinates.length > 1) {\n\n        for (let i = 1; i < coordinates.length; i ++) {\n          //console.log(\"adding line\",coordinates[i-1].x, coordinates[i-1].y, coordinates[i].x, coordinates[i].y)\n          var line =block.addLine(point3d(coordinates[i-1].x, coordinates[i-1].y), point3d(coordinates[i].x, coordinates[i].y));\n          //console.log(\"thickness \",line)\n          line.thickness=strokeWidth;\n          line.lineType=\"CONTINUOUS\";\n          if (line.thickness>0.4) {     \n                line.lineScale=strokeWidth*4;   \n                line.colorNumber = Colors.Black;\n              } else \n          { \n          //  line.lineType=\"DASHED\";\n         \n              line.lineScale=strokeWidth*2; \n               line.colorNumber = Colors.Grey;\n               line.lineTypeScale=strokeWidth*2; \n          }\n        }\n      }\n    }\n\n   \n}\n\n\n\n\n\n\n\n\n  \n}\nexport default BBSVGEditor\n"],"sourceRoot":""}